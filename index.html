<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>무음 호흡 파형 · 카메라 흉부모션 / 가속도</title>
  <style>
    :root{--bg:#0b0f14;--card:#111826;--line:#1e293b;--fg:#e6f0ff;--muted:#8aa0b6;--accent:#6aa6ff;--green:#58d68d;--warn:#ff6b6b}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;background:var(--bg);color:var(--fg)}
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:10px 0 14px}
    .card{background:#111826;border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 12px 30px rgba(0,0,0,.35);margin-bottom:14px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .tabs{display:flex;gap:8px;margin-bottom:8px}
    .tab{padding:10px 12px;border-radius:10px;border:1px solid #243246;background:#0f1623;cursor:pointer}
    .tab.active{border-color:#58d68d;color:#58d68d}
    button{appearance:none;border:0;border-radius:12px;padding:12px 14px;background:var(--accent);color:#001533;font-weight:800}
    button.secondary{background:#1f2a3b;color:var(--fg)}
    .stat{flex:1 1 170px;background:#0e1622;border:1px solid #1e2737;border-radius:12px;padding:12px}
    .big{font-size:26px;font-weight:800}
    .small{font-size:12px;color:var(--muted)}
    canvas{width:100%;height:200px;background:#0e141d;border:1px solid #1e2737;border-radius:12px}
    video{width:100%;max-height:280px;background:#000;border-radius:12px;border:1px solid #1e2737}
    label{font-size:12px;color:#9fb3c7;margin-right:8px}
    input[type=range]{width:180px}
    .hint{color:var(--muted);font-size:12px;margin-top:8px;line-height:1.5}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#0e1622;border:1px solid #243246;color:#cfe3ff;font-size:12px}
    .ok{color:var(--green)} .warn{color:var(--warn)}
    .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>무음 호흡 파형 · 카메라 흉부모션 / 가속도</h1>

    <div class="card">
      <div class="tabs">
        <div id="tabCam" class="tab active">카메라 · 흉부 모션</div>
        <div id="tabAccel" class="tab">가속도 · 가슴 위 폰</div>
      </div>

      <div id="panelCam">
        <div class="row" style="gap:10px;margin-bottom:8px">
          <button id="startCam">카메라 시작</button>
          <button id="stopCam" class="secondary" disabled>중지</button>
          <span class="badge"><span class="small">상태</span> <b id="stateCam">대기</b></span>
          <span class="badge"><span class="small">ROI</span> <b id="roiInfo">중앙 40% 영역</b></span>
        </div>
        <video id="video" playsinline muted></video>
        <canvas id="camCanvas" width="640" height="360" style="display:none"></canvas>
        <div class="row" style="gap:12px; margin-top:8px; flex-wrap:wrap">
          <label>ROI 높이(%) <input id="roiH" type="range" min="20" max="80" step="5" value="40"><span id="roiHv">40</span></label>
          <label>수직 이동 탐색(px) <input id="searchPx" type="range" min="2" max="20" step="1" value="6"><span id="spxv">6</span></label>
          <label>스무딩 α <input id="alphaCam" type="range" min="0.05" max="0.6" step="0.05" value="0.25"><span id="acv">0.25</span></label>
        </div>
      </div>

      <div id="panelAccel" style="display:none">
        <div class="row" style="gap:10px;margin-bottom:8px">
          <button id="startAcc">센서 시작</button>
          <button id="stopAcc" class="secondary" disabled>중지</button>
          <button id="zeroAcc" class="secondary" disabled>제로</button>
          <button id="gainUp" class="secondary" disabled>Gain↑</button>
          <button id="gainDown" class="secondary" disabled>Gain↓</button>
          <span class="badge"><span class="small">상태</span> <b id="stateAcc">대기</b></span>
          <span class="badge"><span class="small">Gain</span> <b id="gainLbl">1.0×</b></span>
        </div>
        <div class="hint">폰을 가슴/복부 위에 올려두고 자연호흡. 센서 권한(모션/자이로) 허용 필요.</div>
      </div>
    </div>

    <div class="card">
      <div class="grid">
        <div class="stat"><div class="small">분당 호흡수 (RPM)</div><div id="rpm" class="big">0.0</div></div>
        <div class="stat"><div class="small">피크 수(최근 30초)</div><div id="peaks" class="big">0</div></div>
        <div class="stat"><div class="small">임계값 K</div><div id="kval" class="big">0.6</div></div>
      </div>
      <div class="row" style="gap:12px; margin-top:10px">
        <button id="kUp" class="secondary">K↑</button>
        <button id="kDown" class="secondary">K↓</button>
      </div>
      <div class="row" style="gap:12px; margin-top:10px; flex-wrap:wrap">
        <label>엔벌로프 스무딩 α <input id="alphaEnv" type="range" min="0.05" max="0.6" step="0.05" value="0.25"><span id="aev">0.25</span></label>
      </div>
      <div class="row" style="gap:12px; margin-top:10px">
        <div class="stat" style="flex:1"><div class="small">원시 파형/변위</div></div>
      </div>
      <canvas id="wave" width="960" height="200"></canvas>
      <div class="row" style="margin-top:10px">
        <div class="stat" style="flex:1"><div class="small">엔벌로프/임계선/피크</div></div>
      </div>
      <canvas id="env" width="960" height="200"></canvas>
      <div class="hint">
        • <b>카메라 모드</b>: 전면/후면 카메라를 가슴/복부가 화면 중앙에 오게 하고, 화면을 최대한 고정. 프레임 간 수직 이동을 소규모 상관관계로 추정. <br>
        • <b>가속도 모드</b>: 중력 분리+적분으로 상대 변위를 추정(드리프트 억제). Gain으로 미세한 움직임 보정. <br>
        • 임계값 K는 민감도. 잡음이 많으면 K↑, 반응이 둔하면 K↓.
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Common detection & UI =====
  const FRAME_SEC = 0.05;
  const WINDOW_SEC = 30;
  const REFRACT_SEC = 1.0;
  let K = 0.6;
  let alphaEnv = 0.25;

  let rafId=null;
  let envBuf=[]; // {t, v}
  let rawBuf=[]; // {t, x} raw value (camera shift px or accel displacement m)
  let lastEnvVal=0, lastEnvTime=0, lastPeakTime=-Infinity;

  // DOM
  const rpmEl = document.getElementById('rpm');
  const peaksEl = document.getElementById('peaks');
  const kvalEl = document.getElementById('kval');
  const wave = document.getElementById('wave');
  const envc = document.getElementById('env');
  const gw = wave.getContext('2d');
  const ge = envc.getContext('2d');
  const kUp = document.getElementById('kUp');
  const kDown = document.getElementById('kDown');
  const alphaEnvR = document.getElementById('alphaEnv');
  const aev = document.getElementById('aev');

  kvalEl.textContent = K.toFixed(1);
  alphaEnvR.addEventListener('input', ()=>{ alphaEnv = +alphaEnvR.value; aev.textContent = alphaEnvR.value; });

  kUp.onclick = ()=>{ K = Math.min(2.0, +(K+0.1).toFixed(1)); kvalEl.textContent = K.toFixed(1); };
  kDown.onclick = ()=>{ K = Math.max(0.1, +(K-0.1).toFixed(1)); kvalEl.textContent = K.toFixed(1); };

  function drawYAxis(ctx, W, H, ticks, toY, labelFmt, padL=40){
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#1e2737'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(padL, 0); ctx.lineTo(padL, H); ctx.stroke();
    ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif';
    ctx.fillStyle = '#8aa0b6';
    ticks.forEach(t => {
      const y = toY(t);
      ctx.strokeStyle = '#1e2737';
      ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W, y); ctx.stroke();
      ctx.fillText(labelFmt(t), 6, y+4);
    });
    return padL;
  }

  function renderRaw(){
    const W = wave.width, H = wave.height;
    const toY = (v)=>{ const top=8, bottom=H-8; const n = 0.5 + 0.5*(v/10); return top + (1-n)*(bottom-top); };
    const padL = drawYAxis(gw, W, H, [-10,-5,0,5,10], toY, v=>v.toFixed(0));
    const N = rawBuf.length; if (N<2) return;
    const t0 = rawBuf[0].t, t1 = rawBuf[N-1].t; const dt = t1-t0 || 1;
    gw.strokeStyle = '#9bd1ff'; gw.lineWidth=2; gw.beginPath();
    for (let i=0;i<N;i++){
      const x = padL + (rawBuf[i].t - t0) / dt * (W - padL - 6);
      const y = toY(rawBuf[i].x);
      if (i===0) gw.moveTo(x,y); else gw.lineTo(x,y);
    }
    gw.stroke();
  }

  function renderEnv(res){
    const W = envc.width, H = envc.height;
    const toY = (v)=>{ const top=8,bottom=H-30; const n=Math.max(0,Math.min(1,v)); return top + (1-n)*(bottom-top); };
    const padL = drawYAxis(ge, W, H, [0,0.25,0.5,0.75,1.0], toY, v=>v.toFixed(2));
    const N = envBuf.length; if (N<2) return;
    const t0 = envBuf[0].t, t1 = envBuf[N-1].t; const dt = t1-t0 || 1;

    ge.strokeStyle = '#6aa6ff'; ge.lineWidth=2; ge.beginPath();
    for (let i=0;i<N;i++){
      const x = padL + (envBuf[i].t - t0) / dt * (W - padL - 6);
      const y = toY(res.norm[i]||0);
      if (i===0) ge.moveTo(x,y); else ge.lineTo(x,y);
    }
    ge.stroke();

    ge.strokeStyle = '#58d68d'; ge.setLineDash([6,6]); ge.beginPath();
    const ythr = toY(res.thr); ge.moveTo(padL, ythr); ge.lineTo(W, ythr); ge.stroke(); ge.setLineDash([]);

    if (res.peaks && res.peaks.length){
      ge.fillStyle = '#ffd166';
      const dtS = FRAME_SEC;
      res.peaks.forEach(tp => {
        const i = Math.max(0, Math.min(N-1, Math.round((tp - t0)/dtS)));
        const x = padL + i*(W - padL - 6)/(N-1);
        const y = toY(res.norm[i]||0);
        ge.beginPath(); ge.arc(x,y,4,0,Math.PI*2); ge.fill();
      });
    }
  }

  function analyze(){
    if (envBuf.length < 5) return { rpm:0, peaks:[], thr:0, norm:[] };
    const vals = envBuf.map(x=>x.v);
    const vmax = Math.max(1e-9, Math.max(...vals));
    const vmin = Math.min(...vals);
    const norm = vals.map(v => (v - vmin) / Math.max(1e-9, (vmax - vmin)));
    const mu = norm.reduce((a,b)=>a+b,0)/norm.length;
    const sigma = Math.sqrt(norm.reduce((s,x)=>s+(x-mu)*(x-mu),0)/norm.length);
    const thr = mu + K*sigma;
    const peaks = [];
    for (let i=1;i<norm.length;i++){
      if (norm[i-1] < thr && norm[i] >= thr){
        const t = envBuf[i].t;
        if (t - lastPeakTime >= REFRACT_SEC){
          peaks.push(t);
          lastPeakTime = t;
        }
      }
    }
    let rpm = 0;
    if (peaks.length >= 2){
      const diffs = [];
      for (let i=1;i<peaks.length;i++){
        const d = peaks[i] - peaks[i-1];
        if (d > 0.8 && d < 10) diffs.push(d);
      }
      if (diffs.length){
        const meanT = diffs.reduce((a,b)=>a+b,0)/diffs.length;
        rpm = 60/meanT;
      }
    }
    return { rpm, peaks, thr, norm };
  }

  function pushRaw(val){
    const now = performance.now()/1000;
    rawBuf.push({t:now, x:val});
    const cutoff = now - WINDOW_SEC;
    while (rawBuf.length && rawBuf[0].t < cutoff) rawBuf.shift();
  }

  function pushEnv(val){
    const now = performance.now()/1000;
    let env = alphaEnv * val + (1 - alphaEnv) * lastEnvVal;
    lastEnvVal = env;
    if ((now - lastEnvTime) >= FRAME_SEC){
      envBuf.push({t:now, v:Math.max(0, Math.abs(env))});
      lastEnvTime = now;
    }
    const cutoff = now - WINDOW_SEC;
    while (envBuf.length && envBuf[0].t < cutoff) envBuf.shift();
  }

  function loopCommon(){
    const res = analyze();
    renderRaw();
    renderEnv(res);
    rpmEl.textContent = (res.rpm||0).toFixed(1);
    peaksEl.textContent = (res.peaks?res.peaks.length:0);
    rafId = requestAnimationFrame(loopCommon);
  }

  // ===== Tab switching =====
  const tabCam = document.getElementById('tabCam');
  const tabAccel = document.getElementById('tabAccel');
  const panelCam = document.getElementById('panelCam');
  const panelAccel = document.getElementById('panelAccel');
  function activateTab(which){
    tabCam.classList.toggle('active', which==='cam');
    tabAccel.classList.toggle('active', which==='acc');
    panelCam.style.display = (which==='cam')?'block':'none';
    panelAccel.style.display = (which==='acc')?'block':'none';
  }
  tabCam.onclick = ()=>activateTab('cam');
  tabAccel.onclick = ()=>activateTab('acc');

  // ===== Camera chest motion =====
  const video = document.getElementById('video');
  const camCanvas = document.getElementById('camCanvas');
  const gcam = camCanvas.getContext('2d');
  const startCamBtn = document.getElementById('startCam');
  const stopCamBtn = document.getElementById('stopCam');
  const stateCam = document.getElementById('stateCam');
  const roiH = document.getElementById('roiH'); const roiHv = document.getElementById('roiHv');
  const searchPxR = document.getElementById('searchPx'); const spxv = document.getElementById('spxv');
  const alphaCamR = document.getElementById('alphaCam'); const acv = document.getElementById('acv');

  roiHv.textContent = roiH.value; spxv.textContent = searchPxR.value; acv.textContent = alphaCamR.value;
  roiH.addEventListener('input', ()=>{ roiHv.textContent = roiH.value; });
  searchPxR.addEventListener('input', ()=>{ spxv.textContent = searchPxR.value; });
  alphaCamR.addEventListener('input', ()=>{ acv.textContent = alphaCamR.value; });

  let camStream=null, camRaf=null;
  let prevStrip=null; // previous ROI luminance strip
  let camAlpha = 0.25;
  alphaCamR.addEventListener('input', ()=>{ camAlpha = +alphaCamR.value; });

  async function startCam(){
    try{
      stateCam.textContent = '권한 요청…';
      camStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' }, audio:false
      });
      video.srcObject = camStream;
      await video.play();
      camCanvas.width = video.videoWidth || 640;
      camCanvas.height = video.videoHeight || 360;
      prevStrip = null;
      startCamBtn.disabled = true; stopCamBtn.disabled = false;
      stateCam.textContent = '수집 중';
      if (!rafId) loopCommon();
      camLoop();
    }catch(e){
      stateCam.textContent = '실패'; console.warn(e);
    }
  }
  function stopCam(){
    if (camRaf) cancelAnimationFrame(camRaf);
    if (camStream) camStream.getTracks().forEach(t=>t.stop());
    startCamBtn.disabled = false; stopCamBtn.disabled = true;
    stateCam.textContent = '중지';
  }
  startCamBtn.onclick = startCam;
  stopCamBtn.onclick = stopCam;

  function camLoop(){
    const W = camCanvas.width, H = camCanvas.height;
    gcam.drawImage(video, 0,0,W,H);
    // ROI: central band with adjustable height
    const roiHeight = Math.floor(H * (+roiH.value / 100));
    const y0 = Math.floor((H - roiHeight)/2);
    const img = gcam.getImageData(0, y0, W, roiHeight);
    const lum = new Float32Array(roiHeight);
    // Compute row-wise average luminance (Y) to form 1D strip
    for (let r=0; r<roiHeight; r++){
      let s=0;
      for (let c=0; c<W; c++){
        const i = ((r*W)+c)*4;
        const R = img.data[i], G = img.data[i+1], B = img.data[i+2];
        // Rec. 601 luma
        s += 0.299*R + 0.587*G + 0.114*B;
      }
      lum[r] = s / W;
    }
    // Normalize strip
    const mean = lum.reduce((a,b)=>a+b,0)/roiHeight;
    for (let r=0;r<roiHeight;r++) lum[r] = (lum[r]-mean);

    let shift = 0;
    if (prevStrip && prevStrip.length===lum.length){
      // search vertical shift maximizing correlation in [-S..S]
      const S = +searchPxR.value|0;
      let bestR = -Infinity, bestK = 0;
      for (let k=-S; k<=S; k++){
        let num=0, den1=0, den2=0;
        for (let r=0; r<roiHeight; r++){
          const r2 = r+k;
          if (r2<0 || r2>=roiHeight) continue;
          const a = prevStrip[r], b = lum[r2];
          num += a*b; den1 += a*a; den2 += b*b;
        }
        const corr = num / Math.max(1e-9, Math.sqrt(den1*den2));
        if (corr > bestR){ bestR = corr; bestK = k; }
      }
      // low-pass filter the shift for stability
      shift = (1-camAlpha)* (rawBuf.length ? rawBuf[rawBuf.length-1].x : 0) + camAlpha*bestK;
      pushRaw(shift);
      pushEnv(Math.abs(shift));
    }else{
      // warm-up
    }
    prevStrip = lum;

    camRaf = requestAnimationFrame(camLoop);
  }

  // ===== Accelerometer mode =====
  const startAccBtn = document.getElementById('startAcc');
  const stopAccBtn = document.getElementById('stopAcc');
  const zeroAccBtn = document.getElementById('zeroAcc');
  const gainUpBtn = document.getElementById('gainUp');
  const gainDownBtn = document.getElementById('gainDown');
  const stateAcc = document.getElementById('stateAcc');
  const gainLbl = document.getElementById('gainLbl');

  let accRunning=false, gain=1.0;
  let gLPF={x:0,y:0,z:0}, ALPHA=0.02, velZ=0, dispZ=0, lastMotionT=null;
  const DAMP_V=0.985, DAMP_X=0.9995;

  function zeroAcc(){
    velZ=0; dispZ=0; lastMotionT=null;
    stateAcc.textContent = '0점 보정';
  }
  function gainUp(){ gain = Math.min(8, +(gain+0.5).toFixed(1)); gainLbl.textContent = gain.toFixed(1)+'×'; }
  function gainDown(){ gain = Math.max(0.5, +(gain-0.5).toFixed(1)); gainLbl.textContent = gain.toFixed(1)+'×'; }

  function onMotion(e){
    const t = performance.now()/1000;
    const dt = (lastMotionT==null) ? 0 : (t - lastMotionT);
    lastMotionT = t;
    const ag = e.accelerationIncludingGravity || {};
    const axg = ag.x ?? 0, ayg = ag.y ?? 0, azg = ag.z ?? 0;
    gLPF.x = (1-ALPHA)*gLPF.x + ALPHA*axg;
    gLPF.y = (1-ALPHA)*gLPF.y + ALPHA*ayg;
    gLPF.z = (1-ALPHA)*gLPF.z + ALPHA*azg;
    const lax = axg - gLPF.x;
    const lay = ayg - gLPF.y;
    const laz = azg - gLPF.z;
    const gmag = Math.hypot(gLPF.x, gLPF.y, gLPF.z) || 9.81;
    const ux = gLPF.x/gmag, uy = gLPF.y/gmag, uz = gLPF.z/gmag;
    const aVert = (lax*ux + lay*uy + laz*uz);
    if (dt>0 && dt<0.5){
      velZ = DAMP_V * (velZ + aVert * dt);
      dispZ = DAMP_X * (dispZ + velZ * dt);
      const h = dispZ * gain * 100; // convert to approx cm-like scale
      pushRaw(h);
      pushEnv(Math.abs(h));
    }
  }

  async function startAcc(){
    if (accRunning) return;
    accRunning = true;
    stateAcc.textContent = '권한 요청…';
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      try{
        const st = await DeviceMotionEvent.requestPermission();
        if (st !== 'granted'){ stateAcc.textContent='권한 거부'; accRunning=false; return; }
      }catch{ stateAcc.textContent='권한 실패'; accRunning=false; return; }
    }
    window.addEventListener('devicemotion', onMotion, true);
    startAccBtn.disabled = true; stopAccBtn.disabled = false; zeroAccBtn.disabled = false; gainUpBtn.disabled = false; gainDownBtn.disabled = false;
    stateAcc.textContent = '수집 중';
    if (!rafId) loopCommon();
  }
  function stopAcc(){
    if (!accRunning) return;
    accRunning=false;
    window.removeEventListener('devicemotion', onMotion, true);
    startAccBtn.disabled = false; stopAccBtn.disabled = true; zeroAccBtn.disabled = true; gainUpBtn.disabled = true; gainDownBtn.disabled = true;
    stateAcc.textContent = '중지';
  }
  startAccBtn.onclick = startAcc;
  stopAccBtn.onclick = stopAcc;
  zeroAccBtn.onclick = zeroAcc;
  gainUpBtn.onclick = gainUp;
  gainDownBtn.onclick = gainDown;

  // ===== Kick off
  // Start the common loop on first start of either mode
})();
</script>
</body>
</html>
