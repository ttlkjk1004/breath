<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>무음 호흡 파형 · 카메라(가슴 위 폰, 프레임간 수직 이동)</title>
  <style>
    :root{--bg:#0b0f14;--card:#111826;--line:#1e293b;--fg:#e6f0ff;--muted:#8aa0b6;--accent:#6aa6ff;--green:#58d68d}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;background:var(--bg);color:var(--fg)}
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:10px 0 14px}
    .card{background:#111826;border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 12px 30px rgba(0,0,0,.35);margin-bottom:14px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{appearance:none;border:0;border-radius:12px;padding:12px 14px;background:var(--accent);color:#001533;font-weight:800}
    button.secondary{background:#1f2a3b;color:var(--fg)}
    .stat{flex:1 1 170px;background:#0e1622;border:1px solid #1e2737;border-radius:12px;padding:12px}
    .big{font-size:26px;font-weight:800}
    .small{font-size:12px;color:var(--muted)}
    canvas{width:100%;height:200px;background:#0e141d;border:1px solid #1e2737;border-radius:12px}
    video{width:100%;max-height:280px;background:#000;border-radius:12px;border:1px solid #1e2737}
    label{font-size:12px;color:#9fb3c7;margin-right:8px}
    input[type=range]{width:180px}
    .hint{color:var(--muted);font-size:12px;margin-top:8px;line-height:1.5}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#0e1622;border:1px solid #243246;color:#cfe3ff;font-size:12px}
    .ok{color:var(--green)}
    .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>무음 호흡 파형 · 카메라(가슴 위 폰, 프레임간 수직 이동)</h1>

    <div class="card">
      <div class="row" style="gap:10px;margin-bottom:8px">
        <button id="startCam">카메라 시작</button>
        <button id="stopCam" class="secondary" disabled>중지</button>
        <button id="recal" class="secondary" disabled>재보정</button>
        <span class="badge"><span class="small">상태</span> <b id="stateCam">대기</b></span>
        <span class="badge"><span class="small">ROI</span> <b id="roiInfo">중앙 40% 영역</b></span>
      </div>
      <div class="hint">
        • 폰을 <b>가슴/복부 위</b>에 올려두고 카메라는 <b>천장 등 고정된 물체</b>를 향하게.<br>
        • 호흡에 따라 폰이 위/아래로 움직이면 배경이 프레임 간 <b>수직으로 미세 이동</b> → 파형 생성.
      </div>
      <video id="video" playsinline muted></video>
      <canvas id="camCanvas" width="640" height="360" style="display:none"></canvas>
      <div class="row" style="gap:12px; margin-top:8px; flex-wrap:wrap">
        <label>ROI 높이(%) <input id="roiH" type="range" min="20" max="80" step="5" value="40"><span id="roiHv">40</span></label>
        <label>수직 탐색(px) <input id="searchPx" type="range" min="2" max="24" step="1" value="8"><span id="spxv">8</span></label>
        <label>참조 업데이트 α <input id="alphaRef" type="range" min="0.02" max="0.5" step="0.02" value="0.12"><span id="arefv">0.12</span></label>
        <label>엔벌로프 α <input id="alphaEnv" type="range" min="0.05" max="0.6" step="0.05" value="0.25"><span id="aenvv">0.25</span></label>
        <label>Gain × <input id="gain" type="range" min="0.5" max="6" step="0.5" value="2"><span id="gainv">2.0</span></label>
      </div>
    </div>

    <div class="card">
      <div class="grid">
        <div class="stat"><div class="small">분당 호흡수 (RPM)</div><div id="rpm" class="big">0.0</div></div>
        <div class="stat"><div class="small">피크 수(최근 30초)</div><div id="peaks" class="big">0</div></div>
        <div class="stat"><div class="small">임계값 K</div><div id="kval" class="big">0.6</div></div>
      </div>
      <div class="row" style="gap:12px; margin-top:10px">
        <button id="kUp" class="secondary">K↑</button>
        <button id="kDown" class="secondary">K↓</button>
        <button id="zero" class="secondary">제로(0점)</button>
      </div>
      <div class="row" style="gap:12px; margin-top:10px">
        <div class="stat" style="flex:1"><div class="small">원시 수직 이동(픽셀) · 실시간</div></div>
      </div>
      <canvas id="wave" width="960" height="200"></canvas>
      <div class="row" style="margin-top:10px">
        <div class="stat" style="flex:1"><div class="small">엔벌로프/임계선/피크</div></div>
      </div>
      <canvas id="env" width="960" height="200"></canvas>
      <div class="hint">
        • K는 민감도(평균+K·표준편차). 잡음이 많으면 K↑, 반응이 둔하면 K↓.<br>
        • 화면이 많이 흔들리면 <b>ROI 높이</b>를 낮추고 <b>α</b>를 키워 안정화. 배경 텍스처(등, 천장 패턴)가 있으면 더 잘 잡힘.
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Parameters =====
  const FRAME_SEC = 0.05;
  const WINDOW_SEC = 30;
  const REFRACT_SEC = 1.0;
  let K = 0.6;
  let alphaEnv = 0.25;
  let alphaRef = 0.12;       // reference strip EMA
  let GAIN = 2.0;

  // ===== DOM =====
  const startBtn = document.getElementById('startCam');
  const stopBtn  = document.getElementById('stopCam');
  const recalBtn = document.getElementById('recal');
  const stateCam = document.getElementById('stateCam');
  const roiInfo = document.getElementById('roiInfo');
  const roiH = document.getElementById('roiH'); const roiHv = document.getElementById('roiHv');
  const searchPx = document.getElementById('searchPx'); const spxv = document.getElementById('spxv');
  const alphaRefR = document.getElementById('alphaRef'); const arefv = document.getElementById('arefv');
  const alphaEnvR = document.getElementById('alphaEnv'); const aenvv = document.getElementById('aenvv');
  const gainR = document.getElementById('gain'); const gainv = document.getElementById('gainv');
  const kUp = document.getElementById('kUp'); const kDown = document.getElementById('kDown');
  const kvalEl = document.getElementById('kval');
  const zeroBtn = document.getElementById('zero');
  const rpmEl = document.getElementById('rpm'); const peaksEl = document.getElementById('peaks');

  const video = document.getElementById('video');
  const camCanvas = document.getElementById('camCanvas'); const gcam = camCanvas.getContext('2d');
  const wave = document.getElementById('wave'); const gw = wave.getContext('2d');
  const envc = document.getElementById('env'); const ge = envc.getContext('2d');

  // UI init
  kvalEl.textContent = K.toFixed(1);
  roiHv.textContent = roiH.value;
  roiInfo.textContent = `중앙 ${roiH.value}% 영역`;
  spxv.textContent = searchPx.value;
  arefv.textContent = alphaRefR.value;
  aenvv.textContent = alphaEnvR.value;
  gainv.textContent = (+gainR.value).toFixed(1);

  roiH.addEventListener('input', ()=>{ roiHv.textContent = roiH.value; roiInfo.textContent = `중앙 ${roiH.value}% 영역`; });
  searchPx.addEventListener('input', ()=>{ spxv.textContent = searchPx.value; });
  alphaRefR.addEventListener('input', ()=>{ alphaRef = +alphaRefR.value; arefv.textContent = alphaRefR.value; });
  alphaEnvR.addEventListener('input', ()=>{ alphaEnv = +alphaEnvR.value; aenvv.textContent = alphaEnvR.value; });
  gainR.addEventListener('input', ()=>{ GAIN = +gainR.value; gainv.textContent = GAIN.toFixed(1); });
  kUp.onclick = ()=>{ K = Math.min(2.0, +(K+0.1).toFixed(1)); kvalEl.textContent = K.toFixed(1); };
  kDown.onclick = ()=>{ K = Math.max(0.1, +(K-0.1).toFixed(1)); kvalEl.textContent = K.toFixed(1); };

  // ===== Buffers & state =====
  let envBuf=[]; let rawBuf=[];
  let lastEnvVal=0, lastEnvTime=0, lastPeakTime=-Infinity;
  let refStrip=null; // EMA reference
  let camStream=null, camRaf=null;

  function zero(){
    envBuf=[]; rawBuf=[]; lastEnvVal=0; lastEnvTime=0; lastPeakTime=-Infinity;
  }
  zeroBtn.onclick = zero;

  function drawYAxis(ctx, W, H, ticks, toY, labelFmt, padL=40){
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#1e2737'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(padL, 0); ctx.lineTo(padL, H); ctx.stroke();
    ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif';
    ctx.fillStyle = '#8aa0b6';
    ticks.forEach(t => {
      const y = toY(t);
      ctx.strokeStyle = '#1e2737';
      ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W, y); ctx.stroke();
      ctx.fillText(labelFmt(t), 6, y+4);
    });
    return padL;
  }

  function renderRaw(){
    const W = wave.width, H = wave.height;
    const toY = (v)=>{ const top=8, bottom=H-8; const n = 0.5 + 0.5*(v/12); return top + (1-n)*(bottom-top); };
    const padL = drawYAxis(gw, W, H, [-12,-6,0,6,12], toY, v=>v.toFixed(0));
    const N = rawBuf.length; if (N<2) return;
    const t0 = rawBuf[0].t, t1 = rawBuf[N-1].t; const dt = t1-t0 || 1;
    gw.strokeStyle = '#9bd1ff'; gw.lineWidth=2; gw.beginPath();
    for (let i=0;i<N;i++){
      const x = padL + (rawBuf[i].t - t0) / dt * (W - padL - 6);
      const y = toY(rawBuf[i].x);
      if (i===0) gw.moveTo(x,y); else gw.lineTo(x,y);
    }
    gw.stroke();
  }

  function renderEnv(res){
    const W = envc.width, H = envc.height;
    const toY = (v)=>{ const top=8,bottom=H-30; const n=Math.max(0,Math.min(1,v)); return top + (1-n)*(bottom-top); };
    const padL = drawYAxis(ge, W, H, [0,0.25,0.5,0.75,1.0], toY, v=>v.toFixed(2));
    const N = envBuf.length; if (N<2) return;
    const t0 = envBuf[0].t, t1 = envBuf[N-1].t; const dt = t1-t0 || 1;

    ge.strokeStyle = '#6aa6ff'; ge.lineWidth=2; ge.beginPath();
    for (let i=0;i<N;i++){
      const x = padL + (envBuf[i].t - t0) / dt * (W - padL - 6);
      const y = toY(res.norm[i]||0);
      if (i===0) ge.moveTo(x,y); else ge.lineTo(x,y);
    }
    ge.stroke();

    ge.strokeStyle = '#58d68d'; ge.setLineDash([6,6]); ge.beginPath();
    const ythr = toY(res.thr); ge.moveTo(padL, ythr); ge.lineTo(W, ythr); ge.stroke(); ge.setLineDash([]);

    if (res.peaks && res.peaks.length){
      ge.fillStyle = '#ffd166';
      const dtS = FRAME_SEC;
      res.peaks.forEach(tp => {
        const i = Math.max(0, Math.min(N-1, Math.round((tp - t0)/dtS)));
        const x = padL + i*(W - padL - 6)/(N-1);
        const y = toY(res.norm[i]||0);
        ge.beginPath(); ge.arc(x,y,4,0,Math.PI*2); ge.fill();
      });
    }
  }

  function analyze(){
    if (envBuf.length < 5) return { rpm:0, peaks:[], thr:0, norm:[] };
    const vals = envBuf.map(x=>x.v);
    const vmax = Math.max(1e-9, Math.max(...vals));
    const vmin = Math.min(...vals);
    const norm = vals.map(v => (v - vmin) / Math.max(1e-9, (vmax - vmin)));
    const mu = norm.reduce((a,b)=>a+b,0)/norm.length;
    const sigma = Math.sqrt(norm.reduce((s,x)=>s+(x-mu)*(x-mu),0)/norm.length);
    const thr = mu + K*sigma;
    const peaks = [];
    for (let i=1;i<norm.length;i++){
      if (norm[i-1] < thr && norm[i] >= thr){
        const t = envBuf[i].t;
        if (t - lastPeakTime >= REFRACT_SEC){
          peaks.push(t);
          lastPeakTime = t;
        }
      }
    }
    let rpm = 0;
    if (peaks.length >= 2){
      const diffs = [];
      for (let i=1;i<peaks.length;i++){
        const d = peaks[i] - peaks[i-1];
        if (d > 0.8 && d < 10) diffs.push(d);
      }
      if (diffs.length){
        const meanT = diffs.reduce((a,b)=>a+b,0)/diffs.length;
        rpm = 60/meanT;
      }
    }
    return { rpm, peaks, thr, norm };
  }

  function pushRaw(val){
    const now = performance.now()/1000;
    rawBuf.push({t:now, x:val});
    const cutoff = now - WINDOW_SEC;
    while (rawBuf.length && rawBuf[0].t < cutoff) rawBuf.shift();
  }

  function pushEnv(val){
    const now = performance.now()/1000;
    let env = alphaEnv * val + (1 - alphaEnv) * lastEnvVal;
    lastEnvVal = env;
    if ((now - lastEnvTime) >= FRAME_SEC){
      envBuf.push({t:now, v:Math.max(0, Math.abs(env))});
      lastEnvTime = now;
    }
    const cutoff = now - WINDOW_SEC;
    while (envBuf.length && envBuf[0].t < cutoff) envBuf.shift();
  }

  function loopCommon(){
    const res = analyze();
    renderRaw();
    renderEnv(res);
    rpmEl.textContent = (res.rpm||0).toFixed(1);
    peaksEl.textContent = (res.peaks?res.peaks.length:0);
    requestAnimationFrame(loopCommon);
  }

  // ===== Camera processing =====
  async function startCam(){
    try{
      stateCam.textContent = '권한 요청…';
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' }, audio:false
      });
      video.srcObject = stream;
      await video.play();
      camCanvas.width = video.videoWidth || 640;
      camCanvas.height = video.videoHeight || 360;
      refStrip = null;
      startBtn.disabled = true; stopBtn.disabled = false; recalBtn.disabled = false;
      stateCam.textContent = '수집 중';
      loopCommon();
      camLoop(stream);
    }catch(e){
      stateCam.textContent = '실패'; console.warn(e);
    }
  }
  function stopCam(){
    const stream = video.srcObject;
    if (stream) stream.getTracks().forEach(t=>t.stop());
    startBtn.disabled = false; stopBtn.disabled = true; recalBtn.disabled = true;
    stateCam.textContent = '중지';
  }
  startBtn.onclick = startCam;
  stopBtn.onclick = stopCam;
  recalBtn.onclick = ()=>{ refStrip=null; };

  function camLoop(stream){
    const W = camCanvas.width, H = camCanvas.height;
    const draw = () => {
      gcam.drawImage(video, 0,0,W,H);
      const roiHeight = Math.floor(H * (+roiH.value / 100));
      const y0 = Math.floor((H - roiHeight)/2);
      const img = gcam.getImageData(0, y0, W, roiHeight);

      // Row luminance strip
      const lum = new Float32Array(roiHeight);
      for (let r=0; r<roiHeight; r++){
        let s=0;
        for (let c=0; c<W; c++){
          const i = ((r*W)+c)*4;
          const R = img.data[i], G = img.data[i+1], B = img.data[i+2];
          s += 0.299*R + 0.587*G + 0.114*B;
        }
        lum[r] = s / W;
      }
      const mean = lum.reduce((a,b)=>a+b,0)/roiHeight;
      for (let r=0;r<roiHeight;r++) lum[r] = (lum[r]-mean);

      // Initialize / update EMA reference
      if (!refStrip || refStrip.length!==lum.length){
        refStrip = new Float32Array(lum);
      }else{
        for (let r=0;r<roiHeight;r++){
          refStrip[r] = (1-alphaRef)*refStrip[r] + alphaRef*lum[r];
        }
      }

      // Cross-correlation vs reference
      const S = +searchPx.value|0;
      let bestR = -Infinity, bestK = 0;
      for (let k=-S; k<=S; k++){
        let num=0, den1=0, den2=0;
        for (let r=0; r<roiHeight; r++){
          const r2 = r+k;
          if (r2<0 || r2>=roiHeight) continue;
          const a = refStrip[r], b = lum[r2];
          num += a*b; den1 += a*a; den2 += b*b;
        }
        const corr = num / Math.max(1e-9, Math.sqrt(den1*den2));
        if (corr > bestR){ bestR = corr; bestK = k; }
      }

      const shift = bestK * GAIN;
      pushRaw(shift);
      pushEnv(Math.abs(shift));

      requestAnimationFrame(draw);
    };
    draw();
  }

})();
</script>
</body>
</html>
