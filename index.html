<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>모바일 호흡 코칭(마이크 기반) · 실시간 파형/엔벌로프/RPM</title>
  <style>
    :root{--bg:#0b0f14;--card:#111826;--line:#1e293b;--fg:#e6f0ff;--muted:#8aa0b6;--accent:#6aa6ff;--green:#58d68d;--warn:#ffb454}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;background:var(--bg);color:var(--fg)}
    .wrap{max-width:940px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:10px 0 14px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:16px;box-shadow:0 12px 30px rgba(0,0,0,.35);margin-bottom:14px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{appearance:none;border:0;border-radius:12px;padding:12px 14px;background:var(--accent);color:#001533;font-weight:800}
    button.secondary{background:#1f2a3b;color:var(--fg)}
    .stat{flex:1 1 170px;background:#0e1622;border:1px solid #1e2737;border-radius:12px;padding:12px}
    .big{font-size:26px;font-weight:800}
    .small{font-size:12px;color:var(--muted)}
    canvas{width:100%;height:200px;background:#0e141d;border:1px solid var(--line);border-radius:12px}
    .hint{color:var(--muted);font-size:12px;margin-top:8px;line-height:1.5}
    .section-title{font-size:13px;color:#9fb3c7;margin:6px 0}
    .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;margin-top:8px}
    input[type=range]{width:180px}
    label{font-size:12px;color:#9fb3c7;margin-right:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>모바일 호흡 코칭(마이크 기반) · 실시간 파형/엔벌로프/RPM</h1>

    <div class="card">
      <div class="row" style="gap:10px; margin-bottom:8px">
        <button id="startBtn">마이크 시작</button>
        <button id="stopBtn" class="secondary" disabled>중지</button>
        <span id="httpsNote" class="stat" style="flex:0 0 auto;padding:8px 10px;display:inline-block">
          <span class="small">상태</span><div id="stateTxt" class="big" style="font-size:16px">대기</div>
        </span>
      </div>

      <div class="grid">
        <div class="stat"><div class="small">분당 호흡수 (RPM)</div><div id="rpm" class="big">0.0</div></div>
        <div class="stat"><div class="small">피크 수(최근 30초)</div><div id="peaks" class="big">0</div></div>
        <div class="stat"><div class="small">임계값 K</div><div id="kval" class="big">0.6</div></div>
      </div>

      <div class="row" style="gap:12px; margin-top:10px">
        <label>하이패스(Hz) <input id="hp" type="range" min="10" max="200" step="10" value="50"><span id="hpv">50</span></label>
        <label>로우패스(Hz) <input id="lp" type="range" min="400" max="2000" step="100" value="900"><span id="lpv">900</span></label>
        <label>스무딩 α <input id="alpha" type="range" min="0.05" max="0.6" step="0.05" value="0.25"><span id="alphav">0.25</span></label>
        <button id="kUp" class="secondary">K↑</button>
        <button id="kDown" class="secondary">K↓</button>
        <button id="calib" class="secondary">노이즈 보정(2초)</button>
      </div>

      <div class="section-title">실시간 원시 파형</div>
      <canvas id="wave" width="900" height="200" aria-label="마이크 파형"></canvas>

      <div class="section-title" style="margin-top:10px">엔벌로프/임계선/피크</div>
      <canvas id="env" width="900" height="200" aria-label="엔벌로프"></canvas>

      <div class="hint">
        • iOS는 <b>HTTPS</b> + 버튼 클릭 이후에만 마이크 접근 가능. 조용한 환경에서 폰을 입/코에서 10–15cm 거리로 테스트. <br>
        • 기본 필터: <b>하이패스 50Hz</b>, <b>로우패스 900Hz</b> (호흡 잡음 대역). 필요시 슬라이더로 조정. <br>
        • K는 민감도. <b>K↑</b> → 더 보수적(피크 덜 잡음), <b>K↓</b> → 더 민감. <br>
        • “노이즈 보정”은 2초간 주변소음을 샘플링하여 배경 레벨을 약하게 빼줌.
      </div>
    </div>
  </div>

<script>
(() => {
  const FRAME_SEC = 0.05;         // envelope sample interval
  const WINDOW_SEC = 30;          // rolling window for stats
  const REFRACT_SEC = 1.0;        // min interval between peaks
  let K = 0.6;                    // threshold scale
  let alphaEnv = 0.25;            // envelope smoothing
  let noiseOffset = 0;            // background offset after calibration

  let audioCtx, analyser, mediaStream, source, hpFilter, lpFilter, gainNode;
  let running = false, rafId=null;
  let envBuf = [];                 // {t, v} raw envelope
  let lastEnvVal = 0, lastEnvTime = 0, lastPeakTime=-Infinity;

  // DOM
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const rpmEl = document.getElementById('rpm');
  const peaksEl = document.getElementById('peaks');
  const kvalEl = document.getElementById('kval');
  const wave = document.getElementById('wave');
  const envc = document.getElementById('env');
  const gw = wave.getContext('2d');
  const ge = envc.getContext('2d');
  const hp = document.getElementById('hp');
  const lp = document.getElementById('lp');
  const hpv = document.getElementById('hpv');
  const lpv = document.getElementById('lpv');
  const alphaR = document.getElementById('alpha');
  const alphav = document.getElementById('alphav');
  const kUp = document.getElementById('kUp');
  const kDown = document.getElementById('kDown');
  const calib = document.getElementById('calib');
  const stateTxt = document.getElementById('stateTxt');

  kvalEl.textContent = K.toFixed(1);
  hpv.textContent = hp.value;
  lpv.textContent = lp.value;
  alphav.textContent = alphaR.value;

  hp.addEventListener('input', ()=>{ hpv.textContent = hp.value; if (hpFilter) hpFilter.frequency.value = +hp.value; });
  lp.addEventListener('input', ()=>{ lpv.textContent = lp.value; if (lpFilter) lpFilter.frequency.value = +lp.value; });
  alphaR.addEventListener('input', ()=>{ alphaEnv = +alphaR.value; alphav.textContent = alphaR.value; });

  kUp.onclick = ()=>{ K = Math.min(2.0, +(K+0.1).toFixed(1)); kvalEl.textContent = K.toFixed(1); };
  kDown.onclick = ()=>{ K = Math.max(0.1, +(K-0.1).toFixed(1)); kvalEl.textContent = K.toFixed(1); };

  async function start(){
    if (running) return;
    running = true;
    kvalEl.textContent = K.toFixed(1);
    stateTxt.textContent = '권한 요청…';

    audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false },
      video: false
    });

    source = audioCtx.createMediaStreamSource(mediaStream);

    // Gain (preamp) – unity by default; keep in chain for future tweaks
    gainNode = audioCtx.createGain(); gainNode.gain.value = 1.0;

    // Filters
    hpFilter = audioCtx.createBiquadFilter();
    hpFilter.type = 'highpass'; hpFilter.frequency.value = +hp.value; hpFilter.Q.value = 0.707;

    lpFilter = audioCtx.createBiquadFilter();
    lpFilter.type = 'lowpass'; lpFilter.frequency.value = +lp.value; lpFilter.Q.value = 0.707;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.0;

    // Connect chain: source -> gain -> HP -> LP -> analyser
    source.connect(gainNode);
    gainNode.connect(hpFilter);
    hpFilter.connect(lpFilter);
    lpFilter.connect(analyser);

    envBuf = []; lastEnvVal=0; lastEnvTime=0; lastPeakTime=-Infinity; noiseOffset=0;
    startBtn.disabled = true; stopBtn.disabled = false;
    stateTxt.textContent = '수집 중';
    loop();
  }

  function stop(){
    running = false;
    startBtn.disabled = false; stopBtn.disabled = true;
    stateTxt.textContent = '중지';
    if (rafId) cancelAnimationFrame(rafId);
    if (mediaStream) mediaStream.getTracks().forEach(t=>t.stop());
    if (audioCtx) audioCtx.close();
  }

  const tmp = new Float32Array(2048);

  function drawYAxis(ctx, W, H, ticks, toY, labelFmt, padL=40){
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#1e2737'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(padL, 0); ctx.lineTo(padL, H); ctx.stroke();
    ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif';
    ctx.fillStyle = '#8aa0b6';
    ticks.forEach(t => {
      const y = toY(t);
      ctx.strokeStyle = '#1e2737';
      ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W, y); ctx.stroke();
      ctx.fillText(labelFmt(t), 6, y+4);
    });
    return padL;
  }

  function computeEnvelope(){
    analyser.getFloatTimeDomainData(tmp);
    const now = performance.now()/1000;
    let sum = 0; for (let i=0;i<tmp.length;i++) sum += tmp[i]*tmp[i];
    const rms = Math.sqrt(sum/tmp.length);
    let env = alphaEnv * rms + (1 - alphaEnv) * lastEnvVal;
    lastEnvVal = env;

    // subtract small background offset (after calibration)
    env = Math.max(0, env - noiseOffset);

    if ((now - lastEnvTime) >= FRAME_SEC){
      envBuf.push({t:now, v:env});
      lastEnvTime = now;
    }
    const cutoff = now - WINDOW_SEC;
    while (envBuf.length && envBuf[0].t < cutoff) envBuf.shift();
  }

  function analyze(){
    if (envBuf.length < 5) return { rpm:0, peaks:[], thr:0, norm:[] };
    const vals = envBuf.map(x=>x.v);
    const vmax = Math.max(1e-9, Math.max(...vals));
    const vmin = Math.min(...vals);
    const norm = vals.map(v => (v - vmin) / Math.max(1e-9, (vmax - vmin)));
    const mu = norm.reduce((a,b)=>a+b,0)/norm.length;
    const sigma = Math.sqrt(norm.reduce((s,x)=>s+(x-mu)*(x-mu),0)/norm.length);
    const thr = mu + K*sigma;

    const peaks = [];
    for (let i=1;i<norm.length;i++){
      if (norm[i-1] < thr && norm[i] >= thr){
        const t = envBuf[i].t;
        if (t - lastPeakTime >= REFRACT_SEC){
          peaks.push(t);
          lastPeakTime = t;
        }
      }
    }
    let rpm = 0;
    if (peaks.length >= 2){
      const diffs = [];
      for (let i=1;i<peaks.length;i++){
        const d = peaks[i] - peaks[i-1];
        if (d > 0.8 && d < 10) diffs.push(d);
      }
      if (diffs.length){
        const meanT = diffs.reduce((a,b)=>a+b,0)/diffs.length;
        rpm = 60/meanT;
      }
    }
    return { rpm, peaks, thr, norm };
  }

  function drawWave(){
    const W = wave.width, H = wave.height;
    const toY = (v)=>{ const top=8, bottom=H-8; const n=(v+1)/2; return top + (1-n)*(bottom-top); };
    const padL = drawYAxis(gw, W, H, [-1,-0.5,0,0.5,1], toY, v=>v.toFixed(1));
    analyser.getFloatTimeDomainData(tmp);
    gw.strokeStyle = '#9bd1ff'; gw.lineWidth = 2; gw.beginPath();
    const N = tmp.length; const plotW = W - padL - 6; const x0 = padL;
    for (let i=0;i<N;i++){
      const x = x0 + i*(plotW/(N-1));
      const y = toY(tmp[i]);
      if (i===0) gw.moveTo(x,y); else gw.lineTo(x,y);
    }
    gw.stroke();
  }

  function drawEnv(res){
    const W = envc.width, H = envc.height;
    const toY = (v)=>{ const top=8,bottom=H-30; const n=Math.max(0,Math.min(1,v)); return top + (1-n)*(bottom-top); };
    const padL = drawYAxis(ge, W, H, [0,0.25,0.5,0.75,1.0], toY, v=>v.toFixed(2));
    if (!envBuf.length) return;
    const N = envBuf.length; const plotW = W - padL - 6; const x0 = padL;

    ge.strokeStyle = '#6aa6ff'; ge.lineWidth = 2; ge.beginPath();
    for (let i=0;i<N;i++){
      const x = x0 + i*(plotW/(N-1));
      const y = toY(res.norm[i]||0);
      if (i===0) ge.moveTo(x,y); else ge.lineTo(x,y);
    }
    ge.stroke();

    // threshold line
    ge.strokeStyle = '#58d68d'; ge.setLineDash([6,6]); ge.beginPath();
    const ythr = toY(res.thr); ge.moveTo(x0, ythr); ge.lineTo(x0+plotW, ythr); ge.stroke(); ge.setLineDash([]);

    // peak markers
    if (res.peaks && res.peaks.length){
      ge.fillStyle = '#ffd166';
      const t0 = envBuf[0].t, dt = FRAME_SEC;
      res.peaks.forEach(tp => {
        const i = Math.max(0, Math.min(N-1, Math.round((tp - t0)/dt)));
        const x = x0 + i*(plotW/(N-1));
        const y = toY(res.norm[i]||0);
        ge.beginPath(); ge.arc(x, y, 4, 0, Math.PI*2); ge.fill();
      });
    }
  }

  function loop(){
    computeEnvelope();
    const res = analyze();
    drawWave();
    drawEnv(res);
    rpmEl.textContent = (res.rpm||0).toFixed(1);
    peaksEl.textContent = (res.peaks?res.peaks.length:0);
    rafId = requestAnimationFrame(loop);
  }

  // 2s background calibration
  calib.onclick = async () => {
    if (!analyser) return;
    stateTxt.textContent = '노이즈 보정 중(2초)…';
    noiseOffset = 0;
    const tStart = performance.now();
    let acc = 0, cnt = 0;
    const buf = new Float32Array(2048);
    while (performance.now() - tStart < 2000){
      analyser.getFloatTimeDomainData(buf);
      let s=0; for (let i=0;i<buf.length;i++) s += buf[i]*buf[i];
      const rms = Math.sqrt(s/buf.length);
      acc += rms; cnt++;
      await new Promise(r=>setTimeout(r,50));
    }
    const avg = acc/Math.max(1,cnt);
    noiseOffset = avg * 0.8; // subtract most of background
    stateTxt.textContent = '수집 중';
  };

  startBtn.onclick = start;
  stopBtn.onclick = stop;
})();
</script>
</body>
</html>
