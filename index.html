<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>모바일 호흡 코칭(마이크) · 파형/엔벌로프/RPM + 코칭</title>
  <style>
    :root{--bg:#0b0f14;--card:#111826;--line:#1e293b;--fg:#e6f0ff;--muted:#8aa0b6;--accent:#6aa6ff;--green:#58d68d;--warn:#ff6b6b;--amber:#ffb454}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;background:var(--bg);color:var(--fg);transition:background-color .25s}
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:10px 0 14px}
    .card{background:#111826;border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 12px 30px rgba(0,0,0,.35);margin-bottom:14px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;margin-top:8px}
    button{appearance:none;border:0;border-radius:12px;padding:12px 14px;background:var(--accent);color:#001533;font-weight:800}
    button.secondary{background:#1f2a3b;color:var(--fg)}
    .stat{flex:1 1 170px;background:#0e1622;border:1px solid #1e2737;border-radius:12px;padding:12px}
    .big{font-size:26px;font-weight:800}
    .small{font-size:12px;color:var(--muted)}
    canvas{width:100%;height:200px;background:#0e141d;border:1px solid #1e2737;border-radius:12px}
    label{font-size:12px;color:#9fb3c7;margin-right:8px}
    input[type=range]{width:180px}
    .hint{color:var(--muted);font-size:12px;margin-top:8px;line-height:1.5}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#0e1622;border:1px solid #243246;color:#cfe3ff;font-size:12px}
    .ok{color:var(--green)} .warn{color:var(--warn)} .amber{color:var(--amber)}
    .coachHud{display:flex;align-items:center;gap:10px;margin-top:6px}
    .phase{font-size:16px;font-weight:800;padding:6px 10px;border-radius:10px;border:1px solid #243246;background:#0f1623}
    .barWrap{flex:1;height:12px;background:#0e1622;border:1px solid #1e2737;border-radius:999px;overflow:hidden}
    .bar{height:100%;background:#6aa6ff;width:0%}
    .toggle{display:flex;align-items:center;gap:6px;padding:6px 8px;border-radius:10px;border:1px solid #243246;background:#0f1623;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>모바일 호흡 코칭(마이크) · 실시간 파형/엔벌로프/RPM + 코칭</h1>

    <div class="card">
      <div class="row" style="gap:10px; margin-bottom:8px">
        <button id="startBtn">마이크 시작</button>
        <button id="stopBtn" class="secondary" disabled>중지</button>
        <span class="badge"><span class="small">상태</span> <b id="stateTxt">대기</b></span>
        <span class="badge"><span class="small">코칭</span> <b id="coachState">끄기</b></span>
        <span class="badge"><span class="small">경보</span> <b id="alertTxt">—</b></span>
      </div>

      <div class="grid">
        <div class="stat"><div class="small">분당 호흡수 (RPM)</div><div id="rpm" class="big">0.0</div></div>
        <div class="stat"><div class="small">피크 수(최근 30초)</div><div id="peaks" class="big">0</div></div>
        <div class="stat"><div class="small">임계값 K</div><div id="kval" class="big">0.6</div></div>
      </div>

      <div class="row" style="gap:12px; margin-top:10px; flex-wrap:wrap">
        <label>하이패스(Hz) <input id="hp" type="range" min="10" max="200" step="10" value="50"><span id="hpv">50</span></label>
        <label>로우패스(Hz) <input id="lp" type="range" min="400" max="2000" step="100" value="900"><span id="lpv">900</span></label>
        <label>스무딩 α <input id="alpha" type="range" min="0.05" max="0.6" step="0.05" value="0.25"><span id="alphav">0.25</span></label>
        <button id="kUp" class="secondary">K↑</button>
        <button id="kDown" class="secondary">K↓</button>
        <button id="calib" class="secondary">노이즈 보정(2초)</button>
      </div>
    </div>

    <div class="card">
      <div class="row" style="gap:10px;flex-wrap:wrap">
        <label>목표 RPM <input id="targetRPM" type="range" min="5" max="18" step="1" value="10"><span id="trpmv">10</span></label>
        <label>흡:호 비율(%) <input id="inhalePct" type="range" min="20" max="80" step="5" value="40"><span id="inhv">40</span></label>
        <label>허용 오차(%) <input id="tolPct" type="range" min="5" max="40" step="5" value="20"><span id="tolv">20</span></label>
        <div class="toggle"><input id="vibe" type="checkbox"><label for="vibe">진동 큐</label></div>
        <div class="toggle"><input id="beep" type="checkbox"><label for="beep">비프음 큐</label></div>
        <button id="coachToggle" class="secondary">코칭 시작</button>
      </div>
      <div class="coachHud">
        <div id="phase" class="phase">대기</div>
        <div class="barWrap"><div id="phaseBar" class="bar"></div></div>
      </div>
      <div class="hint">
        • 코칭은 <b>목표 RPM</b>과 <b>흡:호 비율</b>에 맞춰 화면 색/텍스트/진동/비프음 큐를 줘. <br>
        • 실제 측정 RPM이 목표에서 <b>허용 오차</b>를 넘으면 경보가 뜨고 상단 배경이 살짝 빨개져. <br>
        • 권장 사용: 조용한 환경, 폰을 입/코에서 10–15cm.
      </div>
    </div>

    <div class="card">
      <div class="row">
        <div class="stat" style="flex:1"><div class="small">원시 파형</div></div>
      </div>
      <canvas id="wave" width="960" height="200"></canvas>
      <div class="row" style="margin-top:10px">
        <div class="stat" style="flex:1"><div class="small">엔벌로프/임계선/피크</div></div>
      </div>
      <canvas id="env" width="960" height="200"></canvas>
      <div class="hint">
        • K는 민감도(평균+K·표준편차). 잡음이 많으면 K↑, 반응이 둔하면 K↓. <br>
        • “노이즈 보정”은 2초간 배경소음을 샘플링해 오프셋을 빼줌.
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Detection params =====
  const FRAME_SEC = 0.05;
  const WINDOW_SEC = 30;
  const REFRACT_SEC = 1.0;
  let K = 0.6;
  let alphaEnv = 0.25;
  let noiseOffset = 0;

  // ===== Audio graph =====
  let audioCtx, analyser, mediaStream, source, hpFilter, lpFilter, gainNode, beepOsc;
  let running = false, rafId=null;

  // ===== Buffers/State =====
  let envBuf = [];  // {t, v}
  let lastEnvVal = 0, lastEnvTime = 0, lastPeakTime=-Infinity;
  let lastGoodRPM = 0;

  // ===== Coaching state =====
  let coachOn = false;
  let targetRPM = 10;
  let inhalePct = 0.40; // inhale fraction of cycle
  let tolPct = 0.20;
  let coachTimer = null;
  let phase = '대기'; // '흡입' / '호흡'
  let phaseStart = 0, phaseDur = 0;

  // ===== DOM =====
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const stateTxt = document.getElementById('stateTxt');
  const coachState = document.getElementById('coachState');
  const alertTxt = document.getElementById('alertTxt');
  const rpmEl = document.getElementById('rpm');
  const peaksEl = document.getElementById('peaks');
  const kvalEl = document.getElementById('kval');
  const wave = document.getElementById('wave');
  const envc = document.getElementById('env');
  const gw = wave.getContext('2d');
  const ge = envc.getContext('2d');
  const hp = document.getElementById('hp');
  const lp = document.getElementById('lp');
  const hpv = document.getElementById('hpv');
  const lpv = document.getElementById('lpv');
  const alphaR = document.getElementById('alpha');
  const alphav = document.getElementById('alphav');
  const kUp = document.getElementById('kUp');
  const kDown = document.getElementById('kDown');
  const calib = document.getElementById('calib');

  const targetRPMR = document.getElementById('targetRPM');
  const trpmv = document.getElementById('trpmv');
  const inhalePctR = document.getElementById('inhalePct');
  const inhv = document.getElementById('inhv');
  const tolPctR = document.getElementById('tolPct');
  const tolv = document.getElementById('tolv');
  const coachToggle = document.getElementById('coachToggle');
  const phaseBadge = document.getElementById('phase');
  const phaseBar = document.getElementById('phaseBar');
  const vibe = document.getElementById('vibe');
  const beep = document.getElementById('beep');

  // ===== UI init =====
  kvalEl.textContent = K.toFixed(1);
  hpv.textContent = hp.value;
  lpv.textContent = lp.value;
  alphav.textContent = alphaR.value;
  trpmv.textContent = targetRPMR.value;
  inhv.textContent = inhalePctR.value;
  tolv.textContent = tolPctR.value;

  hp.addEventListener('input', ()=>{ hpv.textContent = hp.value; if (hpFilter) hpFilter.frequency.value = +hp.value; });
  lp.addEventListener('input', ()=>{ lpv.textContent = lp.value; if (lpFilter) lpFilter.frequency.value = +lp.value; });
  alphaR.addEventListener('input', ()=>{ alphaEnv = +alphaR.value; alphav.textContent = alphaR.value; });
  kUp.onclick = ()=>{ K = Math.min(2.0, +(K+0.1).toFixed(1)); kvalEl.textContent = K.toFixed(1); };
  kDown.onclick = ()=>{ K = Math.max(0.1, +(K-0.1).toFixed(1)); kvalEl.textContent = K.toFixed(1); };
  targetRPMR.addEventListener('input', ()=>{ trpmv.textContent = targetRPMR.value; targetRPM = +targetRPMR.value; if (coachOn) scheduleCoachCycle(); });
  inhalePctR.addEventListener('input', ()=>{ inhv.textContent = inhalePctR.value; inhalePct = +inhalePctR.value/100; if (coachOn) scheduleCoachCycle(); });
  tolPctR.addEventListener('input', ()=>{ tolv.textContent = tolPctR.value; tolPct = +tolPctR.value/100; });

  // ===== Start/Stop =====
  async function start(){
    if (running) return;
    running = true;
    stateTxt.textContent = '권한 요청…';

    audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false },
      video: false
    });

    source = audioCtx.createMediaStreamSource(mediaStream);
    gainNode = audioCtx.createGain(); gainNode.gain.value = 1.0;
    hpFilter = audioCtx.createBiquadFilter(); hpFilter.type='highpass'; hpFilter.frequency.value=+hp.value; hpFilter.Q.value=0.707;
    lpFilter = audioCtx.createBiquadFilter(); lpFilter.type='lowpass'; lpFilter.frequency.value=+lp.value; lpFilter.Q.value=0.707;
    analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0;

    // Optionally create a beep oscillator (muted by default)
    beepOsc = audioCtx.createOscillator(); beepOsc.type='sine'; beepOsc.frequency.value = 880;
    const beepGain = audioCtx.createGain(); beepGain.gain.value = 0;
    beepOsc.connect(beepGain).connect(audioCtx.destination);
    beepOsc.start();

    source.connect(gainNode);
    gainNode.connect(hpFilter);
    hpFilter.connect(lpFilter);
    lpFilter.connect(analyser);

    envBuf = []; lastEnvVal=0; lastEnvTime=0; lastPeakTime=-Infinity; noiseOffset=0; lastGoodRPM=0;
    startBtn.disabled = true; stopBtn.disabled = false;
    stateTxt.textContent = '수집 중';
    loop();

    function playBeep(ms=60){
      if (!beep.checked) return;
      const g = beepGain;
      g.gain.cancelScheduledValues(audioCtx.currentTime);
      g.gain.setValueAtTime(0, audioCtx.currentTime);
      g.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.005);
      g.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + ms/1000);
    }
    window._playBeep = playBeep;
  }

  function stop(){
    running = false;
    startBtn.disabled = false; stopBtn.disabled = true;
    stateTxt.textContent = '중지';
    if (rafId) cancelAnimationFrame(rafId);
    if (coachOn) toggleCoach();
    if (mediaStream) mediaStream.getTracks().forEach(t=>t.stop());
    if (audioCtx) audioCtx.close();
  }

  // ===== Envelope & peaks =====
  const tmp = new Float32Array(2048);

  function drawYAxis(ctx, W, H, ticks, toY, labelFmt, padL=40){
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#1e2737'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(padL, 0); ctx.lineTo(padL, H); ctx.stroke();
    ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif';
    ctx.fillStyle = '#8aa0b6';
    ticks.forEach(t => {
      const y = toY(t);
      ctx.strokeStyle = '#1e2737';
      ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W, y); ctx.stroke();
      ctx.fillText(labelFmt(t), 6, y+4);
    });
    return padL;
  }

  function computeEnvelope(){
    analyser.getFloatTimeDomainData(tmp);
    const now = performance.now()/1000;
    let sum = 0; for (let i=0;i<tmp.length;i++) sum += tmp[i]*tmp[i];
    const rms = Math.sqrt(sum/tmp.length);
    let env = alphaEnv * rms + (1 - alphaEnv) * lastEnvVal;
    lastEnvVal = env;
    env = Math.max(0, env - noiseOffset);

    if ((now - lastEnvTime) >= FRAME_SEC){
      envBuf.push({t:now, v:env});
      lastEnvTime = now;
    }
    const cutoff = now - WINDOW_SEC;
    while (envBuf.length && envBuf[0].t < cutoff) envBuf.shift();
  }

  function analyze(){
    if (envBuf.length < 5) return { rpm:0, peaks:[], thr:0, norm:[] };
    const vals = envBuf.map(x=>x.v);
    const vmax = Math.max(1e-9, Math.max(...vals));
    const vmin = Math.min(...vals);
    const norm = vals.map(v => (v - vmin) / Math.max(1e-9, (vmax - vmin)));
    const mu = norm.reduce((a,b)=>a+b,0)/norm.length;
    const sigma = Math.sqrt(norm.reduce((s,x)=>s+(x-mu)*(x-mu),0)/norm.length);
    const thr = mu + K*sigma;
    const peaks = [];
    for (let i=1;i<norm.length;i++){
      if (norm[i-1] < thr && norm[i] >= thr){
        const t = envBuf[i].t;
        if (t - lastPeakTime >= REFRACT_SEC){
          peaks.push(t);
          lastPeakTime = t;
        }
      }
    }
    let rpm = 0;
    if (peaks.length >= 2){
      const diffs = [];
      for (let i=1;i<peaks.length;i++){
        const d = peaks[i] - peaks[i-1];
        if (d > 0.8 && d < 10) diffs.push(d);
      }
      if (diffs.length){
        const meanT = diffs.reduce((a,b)=>a+b,0)/diffs.length;
        rpm = 60/meanT;
      }
    }
    return { rpm, peaks, thr, norm };
  }

  function drawWave(){
    const W = wave.width, H = wave.height;
    const toY = (v)=>{ const top=8, bottom=H-8; const n=(v+1)/2; return top + (1-n)*(bottom-top); };
    const padL = drawYAxis(gw, W, H, [-1,-0.5,0,0.5,1], toY, v=>v.toFixed(1));
    analyser.getFloatTimeDomainData(tmp);
    gw.strokeStyle = '#9bd1ff'; gw.lineWidth = 2; gw.beginPath();
    const N = tmp.length; const plotW = W - padL - 6; const x0 = padL;
    for (let i=0;i<N;i++){
      const x = x0 + i*(plotW/(N-1));
      const y = toY(tmp[i]);
      if (i===0) gw.moveTo(x,y); else gw.lineTo(x,y);
    }
    gw.stroke();
  }

  function drawEnv(res){
    const W = envc.width, H = envc.height;
    const toY = (v)=>{ const top=8,bottom=H-30; const n=Math.max(0,Math.min(1,v)); return top + (1-n)*(bottom-top); };
    const padL = drawYAxis(ge, W, H, [0,0.25,0.5,0.75,1.0], toY, v=>v.toFixed(2));
    if (!envBuf.length) return;
    const N = envBuf.length; const plotW = W - padL - 6; const x0 = padL;

    ge.strokeStyle = '#6aa6ff'; ge.lineWidth = 2; ge.beginPath();
    for (let i=0;i<N;i++){
      const x = x0 + i*(plotW/(N-1));
      const y = toY(res.norm[i]||0);
      if (i===0) ge.moveTo(x,y); else ge.lineTo(x,y);
    }
    ge.stroke();

    ge.strokeStyle = '#58d68d'; ge.setLineDash([6,6]); ge.beginPath();
    const ythr = toY(res.thr); ge.moveTo(x0, ythr); ge.lineTo(x0+plotW, ythr); ge.stroke(); ge.setLineDash([]);

    if (res.peaks && res.peaks.length){
      ge.fillStyle = '#ffd166';
      const t0 = envBuf[0].t, dt = FRAME_SEC;
      res.peaks.forEach(tp => {
        const i = Math.max(0, Math.min(N-1, Math.round((tp - t0)/dt)));
        const x = x0 + i*(plotW/(N-1));
        const y = toY(res.norm[i]||0);
        ge.beginPath(); ge.arc(x, y, 4, 0, Math.PI*2); ge.fill();
      });
    }
  }

  function loop(){
    computeEnvelope();
    const res = analyze();
    drawWave();
    drawEnv(res);

    rpmEl.textContent = (res.rpm||0).toFixed(1);
    peaksEl.textContent = (res.peaks?res.peaks.length:0);

    // coaching alert logic
    handleAlerts(res);

    rafId = requestAnimationFrame(loop);
  }

  // ===== Coaching =====
  function scheduleCoachCycle(){
    if (!coachOn) return;
    clearTimeout(coachTimer);
    const cycle = 60 / targetRPM; // seconds
    const inh = cycle * inhalePct;
    const ex = cycle - inh;

    phase = '흡입'; phaseStart = performance.now()/1000; phaseDur = inh;
    setPhaseUI('#122b1a', '흡입');
    cue();

    coachTimer = setTimeout(()=>{
      phase = '호흡'; phaseStart = performance.now()/1000; phaseDur = ex;
      setPhaseUI('#2b1212', '호흡');
      cue();
      coachTimer = setTimeout(scheduleCoachCycle, ex*1000);
    }, inh*1000);
  }

  function setPhaseUI(bg, label){
    document.body.style.background = bg;
    phaseBadge.textContent = label;
    // animate progress bar
    const start = performance.now();
    const dur = phaseDur*1000;
    phaseBar.style.transition = 'none'; phaseBar.style.width = '0%';
    requestAnimationFrame(()=>{
      phaseBar.style.transition = `width ${dur}ms linear`;
      phaseBar.style.width = '100%';
    });
  }

  function cue(){
    if (vibe.checked && 'vibrate' in navigator){ navigator.vibrate(60); }
    if (window._playBeep) window._playBeep(70);
  }

  function toggleCoach(){
    coachOn = !coachOn;
    coachState.textContent = coachOn ? '켜짐' : '끄기';
    coachToggle.textContent = coachOn ? '코칭 중지' : '코칭 시작';
    if (coachOn){ scheduleCoachCycle(); } else {
      clearTimeout(coachTimer); coachTimer = null;
      document.body.style.background = 'var(--bg)';
      phaseBadge.textContent = '대기'; phaseBar.style.transition='none'; phaseBar.style.width='0%';
    }
  }

  coachToggle.addEventListener('click', ()=>{
    if (!running){ alert('먼저 마이크를 시작해줘'); return; }
    toggleCoach();
  });

  // ===== Alerts & irregularity =====
  function handleAlerts(res){
    // compute deviation from target
    const rpm = res.rpm || 0;
    const target = targetRPM;
    const tol = tolPct * target;
    let msg = '정상';
    let warn = false;

    if (coachOn && target > 0){
      if (rpm === 0){
        // if no peaks for >8s: breath-hold or signal loss
        const now = performance.now()/1000;
        const latestT = envBuf.length ? envBuf[envBuf.length-1].t : 0;
        if (now - lastPeakTime > 8){
          msg = '신호 약함/무호흡?'; warn = true;
        } else {
          msg = '동기화 대기'; warn = false;
        }
      } else if (Math.abs(rpm - target) > tol){
        msg = '목표 RPM 벗어남'; warn = true;
      } else {
        msg = '목표 범위 내';
      }
    } else {
      msg = '모니터링 중';
    }

    alertTxt.textContent = msg;
    alertTxt.classList.toggle('warn', warn);
    document.body.style.boxShadow = warn ? 'inset 0 0 0 9999px rgba(255,0,0,0.08)' : 'none';
  }

  // ===== Calibration =====
  calib.onclick = async () => {
    if (!analyser) return;
    stateTxt.textContent = '노이즈 보정 중(2초)…';
    noiseOffset = 0;
    const tStart = performance.now();
    let acc = 0, cnt = 0;
    const buf = new Float32Array(2048);
    while (performance.now() - tStart < 2000){
      analyser.getFloatTimeDomainData(buf);
      let s=0; for (let i=0;i<buf.length;i++) s += buf[i]*buf[i];
      const rms = Math.sqrt(s/buf.length);
      acc += rms; cnt++;
      await new Promise(r=>setTimeout(r,50));
    }
    const avg = acc/Math.max(1,cnt);
    noiseOffset = avg * 0.8;
    stateTxt.textContent = '수집 중';
  };

  // ===== Draw loop control =====
  startBtn.onclick = start;
  stopBtn.onclick = stop;

})();
</script>
</body>
</html>
