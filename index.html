<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>모바일 높낮이(고도) 실시간 · 바리오+지오로케이션</title>
  <style>
    :root{--bg:#0b0f14;--card:#111826;--line:#1e293b;--fg:#e6f0ff;--muted:#8aa0b6;--accent:#6aa6ff;--green:#58d68d;--warn:#ffb454}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;background:var(--bg);color:var(--fg)}
    .wrap{max-width:940px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:10px 0 14px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:16px;box-shadow:0 12px 30px rgba(0,0,0,.35);margin-bottom:14px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{appearance:none;border:0;border-radius:12px;padding:12px 14px;background:var(--accent);color:#001533;font-weight:800}
    button.secondary{background:#1f2a3b;color:var(--fg)}
    .stat{flex:1 1 170px;background:#0e1622;border:1px solid #1e2737;border-radius:12px;padding:12px}
    .big{font-size:26px;font-weight:800}
    .small{font-size:12px;color:var(--muted)}
    canvas{width:100%;height:200px;background:#0e141d;border:1px solid var(--line);border-radius:12px}
    .hint{color:var(--muted);font-size:12px;margin-top:8px;line-height:1.5}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#0e1622;border:1px solid #243246;color:#cfe3ff;font-size:12px}
    .ok{color:var(--green)} .warn{color:var(--warn)}
    .section-title{font-size:13px;color:#9fb3c7;margin:6px 0}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>모바일 높낮이(고도) 실시간 · 바리오+지오로케이션</h1>
    <div class="card">
      <div class="row" style="gap:10px; margin-bottom:8px">
        <button id="startBtn">시작(센서)</button>
        <button id="stopBtn" class="secondary" disabled>중지</button>
        <span id="secNote" class="badge">HTTPS 권장</span>
        <span id="srcNote" class="badge">소스: 대기중</span>
      </div>
      <div class="row" style="gap:10px; margin-bottom:8px">
        <div class="stat"><div class="small">상대 높이 Δh (cm)</div><div id="hRel" class="big">0.0</div></div>
        <div class="stat"><div class="small">상승/하강 속도 (cm/s)</div><div id="vRate" class="big">0.0</div></div>
        <div class="stat"><div class="small">데이터 소스</div><div id="src" class="big">—</div></div>
      </div>
      <div class="section-title">높이(Δh) 타임시리즈 — 시작 시점을 0으로 보정</div>
      <canvas id="hChart" width="900" height="200" aria-label="상대 고도 그래프"></canvas>
      <div class="hint">
        • 우선순위: <b>Barometer(기압)</b> → <b>Geolocation.altitude</b>. 가능한 경우 두 소스를 융합(평균)해서 더 안정적인 값을 보여줘. <br>
        • 시작 버튼을 누르면 기준점(P₀ 또는 h₀)을 잡고 이후 값은 상대 높이(Δh)를 표시해. <br>
        • 실내에서는 GPS 고도가 <i>null</i>일 수 있어. 이때는 기압 센서만 사용해.
      </div>
    </div>

    <div class="card">
      <div class="section-title">호흡 코칭(선택): Δh 파형 기반 피크 감지</div>
      <div class="row" style="gap:10px; margin-bottom:8px">
        <div class="stat"><div class="small">임계값 k</div><div id="kval" class="big">0.6</div></div>
        <div class="stat"><div class="small">분당 호흡수(RPM)</div><div id="rpm" class="big">0.0</div></div>
        <div class="stat"><div class="small">피크(최근 30초)</div><div id="peaks" class="big">0</div></div>
      </div>
      <div class="row">
        <button id="kUp" class="secondary">k↑</button>
        <button id="kDown" class="secondary">k↓</button>
        <span class="hint">휴대폰을 <b>가슴/배 위</b>에 올려 놓으면 들숨·날숨에 따라 Δh가 위아래로 움직여. 그 파형의 피크를 잡아서 RPM을 추정해.</span>
      </div>
    </div>
  </div>

<script>
(() => {
  const secNote = document.getElementById('secNote');
  const srcNote = document.getElementById('srcNote');
  const isHTTPS = window.isSecureContext;
  secNote.textContent = isHTTPS ? '보안 컨텍스트 OK' : 'HTTPS 권장(iOS 필요)';
  if (!isHTTPS) secNote.classList.add('warn'); else secNote.classList.add('ok');

  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const hRelEl = document.getElementById('hRel');
  const vRateEl = document.getElementById('vRate');
  const srcEl = document.getElementById('src');
  const canvas = document.getElementById('hChart');
  const g = canvas.getContext('2d');
  const kvalEl = document.getElementById('kval');
  const rpmEl = document.getElementById('rpm');
  const peaksEl = document.getElementById('peaks');
  const kUp = document.getElementById('kUp');
  const kDown = document.getElementById('kDown');

  let refPressure = null; // Pa
  let refAltGeo = null;   // m
  let lastH = 0;
  let lastT = null;
  let hBuf = [];
  let running = false;
  let watchId = null;
  let baro = null;
  let srcs = { baro:false, geo:false };

  let K = 0.6;
  let lastPeakTime = -Infinity;
  const FRAME_SEC = 0.1;
  const WINDOW_SEC = 30;
  const MIN_BREATH_SEC = 1.0;
  let lastFrameTime = 0;
  let normBuf = [];

  function drawAxes(){
    const W = canvas.width, H = canvas.height;
    g.fillStyle = '#0b1220'; g.fillRect(0,0,W,H);
    g.strokeStyle = '#1e2737';
    const padL = 46, padB = 18, padT = 8, padR = 6;
    g.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif';
    g.fillStyle = '#8aa0b6';
    const cmRange = 10;
    for (let cm = -cmRange; cm <= cmRange; cm += 2){
      const y = mapY(cm/100, H, padT, padB);
      g.strokeStyle = '#1e2737';
      g.beginPath(); g.moveTo(padL, y); g.lineTo(W-padR, y); g.stroke();
      g.fillText((cm>=0?'+':'') + cm + 'cm', 6, y+4);
    }
    g.beginPath(); g.moveTo(padL, padT); g.lineTo(padL, H - padB); g.stroke();
    return { padL, padR, padT, padB };
  }

  function mapY(h_m, H, padT, padB){
    const cmRange = 10;
    const top = padT, bottom = H - padB;
    const span = 2*cmRange/100;
    let n = (h_m + cmRange/100) / span;
    n = Math.max(0, Math.min(1, n));
    return top + (1-n)*(bottom-top);
  }

  function render(){
    if (!running) return;
    const W = canvas.width, H = canvas.height;
    const { padL, padR, padT, padB } = drawAxes();

    const now = performance.now()/1000;
    const cutoff = now - 30;
    hBuf = hBuf.filter(p => p.t >= cutoff);
    if (hBuf.length < 2) return;

    const t0 = hBuf[0].t, t1 = hBuf[hBuf.length-1].t;
    const dt = t1 - t0 || 1;
    g.strokeStyle = '#6aa6ff'; g.lineWidth = 2; g.beginPath();
    for (let i=0;i<hBuf.length;i++){
      const x = padL + (hBuf[i].t - t0) / dt * (W - padL - padR);
      const y = mapY(hBuf[i].h, H, padT, padB);
      if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();
  }

  function relAltFromPressure(pPa){
    if (refPressure == null) { refPressure = pPa; return 0; }
    const p0 = refPressure, p = pPa;
    return 8434 * Math.log(p0 / p);
  }

  function onBaroReading(pressureValue){
    let pPa = pressureValue;
    if (pPa < 200) { pPa = pressureValue * 1000; }       // kPa → Pa
    else if (pPa < 2000) { pPa = pressureValue * 100; }  // hPa → Pa
    const h = relAltFromPressure(pPa);
    feedHeight(h, 'baro');
  }

  function onGeo(position){
    const alt = position.coords.altitude;
    const acc = position.coords.altitudeAccuracy;
    if (alt == null) return;
    if (refAltGeo == null) refAltGeo = alt;
    const h = alt - refAltGeo;
    feedHeight(h, 'geo', acc);
  }

  function fuseHeights(hBaro, hGeo, acc){
    if (hBaro == null) return hGeo;
    if (hGeo == null) return hBaro;
    const wGeo = (acc && acc>0) ? Math.max(0.1, Math.min(0.9, 1/(acc/3))) : 0.5;
    const wBaro = 1 - wGeo;
    return wBaro*hBaro + wGeo*hGeo;
  }

  let lastBaroH = null, lastGeoH = null, lastGeoAcc = null;

  function feedHeight(h, src, acc){
    const now = performance.now()/1000;
    if (src === 'baro'){ lastBaroH = h; }
    if (src === 'geo'){ lastGeoH = h; lastGeoAcc = acc; }
    const fused = fuseHeights(lastBaroH, lastGeoH, lastGeoAcc);

    if (lastT != null){
      const v = (fused - lastH) / (now - lastT);
      vRateEl.textContent = (v*100).toFixed(1);
    }
    lastH = fused; lastT = now;
    hBuf.push({ t: now, h: fused });

    hRelEl.textContent = (fused*100).toFixed(1);
    const srcText = srcs.baro && srcs.geo ? '바리오+지오 융합' : (srcs.baro ? '바리오' : '지오로케이션');
    srcEl.textContent = srcText; srcNote.textContent = srcText;

    // Peak logic
    if (!lastFrameTime || now - lastFrameTime >= FRAME_SEC){
      lastFrameTime = now;
      const vals = hBuf.map(p=>p.h);
      const vmin = Math.min(...vals), vmax = Math.max(...vals);
      const span = Math.max(1e-6, vmax - vmin);
      const n = (fused - vmin) / span;
      normBuf.push({t:now, n});
      while (normBuf.length && normBuf[0].t < now - WINDOW_SEC) normBuf.shift();

      const arr = normBuf.map(x=>x.n);
      const mu = arr.reduce((a,b)=>a+b,0)/arr.length || 0;
      const sig = Math.sqrt(arr.reduce((s,x)=>s+(x-mu)*(x-mu),0)/arr.length || 0);
      const thr = mu + K*sig;
      const L = normBuf.length;
      if (L>=2){
        const a = normBuf[L-2], b = normBuf[L-1];
        if (a.n < thr && b.n >= thr){
          if (b.t - lastPeakTime >= MIN_BREATH_SEC){
            lastPeakTime = b.t;
          }
        }
      }
      const peaks = [];
      for (let i=1;i<normBuf.length;i++){
        const thrI = mu + K*sig;
        if (normBuf[i-1].n < thrI && normBuf[i].n >= thrI){
          if (!peaks.length || normBuf[i].t - peaks[peaks.length-1] >= MIN_BREATH_SEC){
            peaks.push(normBuf[i].t);
          }
        }
      }
      peaksEl.textContent = peaks.length;
      if (peaks.length >= 2){
        const diffs = [];
        for (let i=1;i<peaks.length;i++){
          const d = peaks[i]-peaks[i-1];
          if (d>0.8 && d<10) diffs.push(d);
        }
        if (diffs.length){
          const meanT = diffs.reduce((a,b)=>a+b,0)/diffs.length;
          rpmEl.textContent = (60/meanT).toFixed(1);
        }
      }
    }

    render();
  }

  async function start(){
    if (running) return;
    running = true;
    srcNote.textContent = '소스 초기화 중…';
    startBtn.disabled = true; stopBtn.disabled = false;
    refPressure = null; refAltGeo = null; lastH = 0; lastT = null;
    hBuf = []; normBuf = []; lastPeakTime = -Infinity;
    srcs = {baro:false, geo:false};

    try{
      if ('Barometer' in window){
        baro = new Barometer({ frequency: 10 });
        baro.addEventListener('reading', () => {
          srcs.baro = true;
          onBaroReading(baro.pressure ?? baro.reading?.pressure ?? baro.reading?.pressureValue);
        });
        baro.addEventListener('error', e => { console.warn('baro error', e); });
        baro.start();
      }
    }catch(e){ console.warn('Barometer start failed', e); }

    try{
      if ('geolocation' in navigator){
        watchId = navigator.geolocation.watchPosition(onGeo, (err)=>{
          console.warn('geo error', err);
        }, { enableHighAccuracy:true, maximumAge:500, timeout:8000 });
      }
    }catch(e){ console.warn('geo watch failed', e); }

    srcNote.textContent = '수집 중…';
  }

  function stop(){
    running = false;
    startBtn.disabled = false; stopBtn.disabled = true;
    try{
      if (watchId != null) navigator.geolocation.clearWatch(watchId);
      watchId = null;
      if (baro && baro.stop) baro.stop();
    }catch(e){}
  }

  startBtn.onclick = start;
  stopBtn.onclick = stop;

  kvalEl.textContent = K.toFixed(1);
  kUp.onclick = ()=>{ K = Math.min(1.2, K+0.1); kvalEl.textContent = K.toFixed(1); };
  kDown.onclick = ()=>{ K = Math.max(0.1, K-0.1); kvalEl.textContent = K.toFixed(1); };
})();
</script>
</body>
</html>
