<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>모바일 높낮이(고도) 실시간 · 바리오/지오/가속도 Fallback</title>
  <style>
    :root{--bg:#0b0f14;--card:#111826;--line:#1e293b;--fg:#e6f0ff;--muted:#8aa0b6;--accent:#6aa6ff;--green:#58d68d;--warn:#ffb454;--amber:#ffcd60}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;background:var(--bg);color:var(--fg)}
    .wrap{max-width:940px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:10px 0 14px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:16px;box-shadow:0 12px 30px rgba(0,0,0,.35);margin-bottom:14px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{appearance:none;border:0;border-radius:12px;padding:12px 14px;background:var(--accent);color:#001533;font-weight:800}
    button.secondary{background:#1f2a3b;color:var(--fg)}
    .stat{flex:1 1 170px;background:#0e1622;border:1px solid #1e2737;border-radius:12px;padding:12px}
    .big{font-size:26px;font-weight:800}
    .small{font-size:12px;color:var(--muted)}
    canvas{width:100%;height:200px;background:#0e141d;border:1px solid var(--line);border-radius:12px}
    .hint{color:var(--muted);font-size:12px;margin-top:8px;line-height:1.5}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#0e1622;border:1px solid #243246;color:#cfe3ff;font-size:12px}
    .ok{color:var(--green)} .warn{color:var(--warn)} .amber{color:var(--amber)}
    .section-title{font-size:13px;color:#9fb3c7;margin:6px 0}
    .srcs{display:flex;flex-wrap:wrap;gap:6px}
    .tag{padding:3px 8px;border-radius:999px;border:1px solid #2a3950;background:#0f1623}
    .on{border-color:#58d68d;color:#58d68d}
    .off{border-color:#3a465a;color:#8aa0b6}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>모바일 높낮이(고도) 실시간 · 바리오/지오/가속도 Fallback</h1>
    <div class="card">
      <div class="row" style="gap:10px; margin-bottom:8px">
        <button id="startBtn">시작(센서)</button>
        <button id="stopBtn" class="secondary" disabled>중지</button>
        <span id="secNote" class="badge">HTTPS 권장</span>
        <span id="statusNote" class="badge">대기 중</span>
      </div>
      <div class="srcs">
        <span id="tagBaro" class="tag off">Barometer</span>
        <span id="tagGeo" class="tag off">Geolocation.alt</span>
        <span id="tagAccel" class="tag off">Accelerometer(추정)</span>
      </div>
      <div class="row" style="gap:10px; margin:10px 0 8px">
        <div class="stat"><div class="small">상대 높이 Δh (cm)</div><div id="hRel" class="big">—</div></div>
        <div class="stat"><div class="small">상승/하강 속도 (cm/s)</div><div id="vRate" class="big">—</div></div>
        <div class="stat"><div class="small">활성 소스</div><div id="src" class="big">—</div></div>
      </div>
      <div class="section-title">높이(Δh) 타임시리즈 — 시작 시점을 0으로 보정</div>
      <canvas id="hChart" width="900" height="200" aria-label="상대 고도 그래프"></canvas>
      <div class="hint">
        • 우선순위: <b>Barometer</b> → <b>Geolocation.altitude</b> → <b>Accelerometer 추정</b> (둘 다 불가 시). <br>
        • iOS 사파리는 Barometer 미지원일 수 있고, 실내 GPS 고도는 null일 수 있어. 이럴 땐 가속도 기반 추정으로 상대 높낮이만 표시(절대 고도 아님).
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== UI =====
  const secNote = document.getElementById('secNote');
  const statusNote = document.getElementById('statusNote');
  const tagBaro = document.getElementById('tagBaro');
  const tagGeo = document.getElementById('tagGeo');
  const tagAccel = document.getElementById('tagAccel');
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const hRelEl = document.getElementById('hRel');
  const vRateEl = document.getElementById('vRate');
  const srcEl = document.getElementById('src');
  const canvas = document.getElementById('hChart');
  const g = canvas.getContext('2d');

  const isHTTPS = window.isSecureContext;
  secNote.textContent = isHTTPS ? '보안 컨텍스트 OK' : 'HTTPS 권장(iOS 필요)';
  if (!isHTTPS) secNote.classList.add('warn'); else secNote.classList.add('ok');

  function setTag(el, on){ el.classList.toggle('on', on); el.classList.toggle('off', !on); }

  // ===== Data state =====
  let running = false;
  let hBuf = []; // {t, h} meters
  let lastH = null, lastT = null;

  // Sources
  let refPressure = null; // Pa
  let baro = null, baroActive = false;
  let watchId = null, geoActive = false, refAltGeo = null;
  let accelActive = false;

  // Accelerometer-based estimation (fallback)
  let velZ = 0, dispZ = 0;
  let lastMotionT = null;
  const DAMP_V = 0.98;  // velocity damping (to fight drift)
  const DAMP_X = 0.999; // displacement slow drift clamp

  // ===== Rendering =====
  function drawAxes(){
    const W = canvas.width, H = canvas.height;
    g.fillStyle = '#0b1220'; g.fillRect(0,0,W,H);
    g.strokeStyle = '#1e2737';
    const padL = 46, padB = 18, padT = 8, padR = 6;
    g.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif';
    g.fillStyle = '#8aa0b6';
    const cmRange = 10;
    for (let cm = -cmRange; cm <= cmRange; cm += 2){
      const y = mapY(cm/100, H, padT, padB);
      g.strokeStyle = '#1e2737';
      g.beginPath(); g.moveTo(padL, y); g.lineTo(W-padR, y); g.stroke();
      g.fillText((cm>=0?'+':'') + cm + 'cm', 6, y+4);
    }
    g.beginPath(); g.moveTo(padL, padT); g.lineTo(padL, H - padB); g.stroke();
    return { padL, padR, padT, padB };
  }

  function mapY(h_m, H, padT, padB){
    const cmRange = 10;
    const top = padT, bottom = H - padB;
    const span = 2*cmRange/100;
    let n = (h_m + cmRange/100) / span;
    n = Math.max(0, Math.min(1, n));
    return top + (1-n)*(bottom-top);
  }

  function render(){
    const W = canvas.width, H = canvas.height;
    const { padL, padR, padT, padB } = drawAxes();
    const now = performance.now()/1000;
    const cutoff = now - 30;
    hBuf = hBuf.filter(p => p.t >= cutoff);
    if (hBuf.length < 2) return;
    const t0 = hBuf[0].t, t1 = hBuf[hBuf.length-1].t;
    const dt = t1 - t0 || 1;
    g.strokeStyle = '#6aa6ff'; g.lineWidth = 2; g.beginPath();
    for (let i=0;i<hBuf.length;i++){
      const x = padL + (hBuf[i].t - t0) / dt * (W - padL - padR);
      const y = mapY(hBuf[i].h, H, padT, padB);
      if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();
  }

  // ===== Fusion helpers =====
  function relAltFromPressure(pPa){
    if (refPressure == null) { refPressure = pPa; return 0; }
    const p0 = refPressure, p = pPa;
    return 8434 * Math.log(p0 / p); // meters
  }

  function fuseHeights(hBaro, hGeo, acc){
    const hasBaro = (typeof hBaro === 'number' && isFinite(hBaro));
    const hasGeo  = (typeof hGeo === 'number'  && isFinite(hGeo));
    if (hasBaro && hasGeo){
      const wGeo = (acc && acc>0) ? Math.max(0.1, Math.min(0.9, 1/(acc/3))) : 0.5;
      const wBaro = 1 - wGeo;
      return wBaro*hBaro + wGeo*hGeo;
    } else if (hasBaro) return hBaro;
    else if (hasGeo) return hGeo;
    return null;
  }

  // ===== Feed a new height sample (meters) =====
  function feedHeight(h_m, srcLabel){
    const now = performance.now()/1000;
    if (typeof h_m !== 'number' || !isFinite(h_m)) return;

    if (lastT != null && lastH != null){
      const v = (h_m - lastH) / (now - lastT); // m/s
      vRateEl.textContent = (v*100).toFixed(1); // cm/s
    }
    lastH = h_m; lastT = now;
    hBuf.push({ t: now, h: h_m });

    hRelEl.textContent = (h_m*100).toFixed(1);
    srcEl.textContent = srcLabel;
    render();
  }

  // ===== Barometer =====
  let lastBaroH = null;
  function startBarometer(){
    try{
      if ('Barometer' in window){
        baro = new Barometer({ frequency: 10 });
        baro.addEventListener('reading', () => {
          baroActive = true; setTag(tagBaro, true);
          let p = baro.pressure ?? baro.reading?.pressure ?? baro.reading?.pressureValue;
          if (typeof p !== 'number') return;
          // normalize units
          if (p < 200) p *= 1000; else if (p < 2000) p *= 100;
          lastBaroH = relAltFromPressure(p);
          // defer fusion in main tick with geolocation if any
        });
        baro.addEventListener('error', e => { console.warn('baro error', e); });
        baro.start();
      }
    }catch(e){
      console.warn('Barometer start failed', e);
    }
  }

  // ===== Geolocation =====
  let lastGeoH = null, lastGeoAcc = null;
  function startGeolocation(){
    try{
      if ('geolocation' in navigator){
        watchId = navigator.geolocation.watchPosition((pos)=>{
          geoActive = true; setTag(tagGeo, true);
          const alt = pos.coords.altitude;
          if (alt == null) return;
          if (refAltGeo == null) refAltGeo = alt;
          lastGeoH = alt - refAltGeo;
          lastGeoAcc = pos.coords.altitudeAccuracy;
        }, (err)=>{
          console.warn('geo error', err);
        }, { enableHighAccuracy:true, maximumAge:500, timeout:8000 });
      }
    }catch(e){
      console.warn('geo start failed', e);
    }
  }

  // ===== Accelerometer fallback (DeviceMotion) =====
  function startAccelerometer(){
    function onMotion(e){
      accelActive = true; setTag(tagAccel, true);
      const t = performance.now()/1000;
      const dt = (lastMotionT==null) ? 0 : (t - lastMotionT);
      lastMotionT = t;

      // vertical axis: project linear acceleration onto gravity direction
      const ag = e.accelerationIncludingGravity || {};
      const a  = e.acceleration || {};
      if (ag.x==null || ag.y==null || ag.z==null) return;

      // Gravity vector (approx) from includingGravity minus linear acceleration is unstable on some devices.
      // Use includingGravity normalized as gravity direction; then use linear acceleration (a) magnitude on that axis.
      const gx = ag.x, gy = ag.y, gz = ag.z;
      const gnorm = Math.hypot(gx, gy, gz) || 9.81;
      const ux = gx/gnorm, uy = gy/gnorm, uz = gz/gnorm; // up-direction approx (device coords)

      const ax = a.x||0, ay = a.y||0, az = a.z||0; // m/s^2 (linear accel; may be null on iOS → becomes 0)
      const aVert = ax*ux + ay*uy + az*uz; // along gravity axis (up positive)

      // Integrate to velocity/position with damping to curb drift
      if (dt>0 && dt<0.5){
        velZ = DAMP_V * (velZ + aVert * dt);
        dispZ = DAMP_X * (dispZ + velZ * dt);
        // clamp extreme drift
        if (Math.abs(dispZ) > 0.25) dispZ *= 0.95;
      }

      feedHeight(dispZ, activeSourceLabel());
    }

    function requestPermAndStart(){
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
        DeviceMotionEvent.requestPermission().then(state => {
          if (state === 'granted'){
            window.addEventListener('devicemotion', onMotion, true);
          }else{
            statusNote.textContent = '가속도 권한 거부'; statusNote.classList.add('warn');
          }
        }).catch(()=>{
          statusNote.textContent = '가속도 권한 요청 실패'; statusNote.classList.add('warn');
        });
      }else{
        window.addEventListener('devicemotion', onMotion, true);
      }
    }
    requestPermAndStart();
  }

  function activeSourceLabel(){
    const parts = [];
    if (baroActive) parts.push('Baro');
    if (geoActive) parts.push('Geo');
    if (!baroActive && !geoActive && accelActive) parts.push('Accel');
    return parts.join('+') || '—';
  }

  // ===== Main tick: fuse baro+geo if present; else accel pushes directly =====
  function tick(){
    if (!running){ requestAnimationFrame(tick); return; }
    const fused = fuseHeights(lastBaroH, lastGeoH, lastGeoAcc);
    if (fused != null){
      feedHeight(fused, activeSourceLabel());
    }else{
      // if no baro/geo yet, accelerometer handler feeds
    }
    requestAnimationFrame(tick);
  }

  // ===== Start/Stop =====
  function startAll(){
    if (running) return;
    running = true;
    statusNote.textContent = '수집 중'; statusNote.classList.remove('warn'); statusNote.classList.add('ok');
    startBtn.disabled = true; stopBtn.disabled = false;

    // reset
    hBuf = []; lastH = null; lastT = null;
    refPressure = null; refAltGeo = null;
    lastBaroH = null; lastGeoH = null; lastGeoAcc = null;
    baroActive = geoActive = accelActive = false;
    setTag(tagBaro, false); setTag(tagGeo, false); setTag(tagAccel, false);
    hRelEl.textContent = '0.0'; vRateEl.textContent = '0.0'; srcEl.textContent = '—';
    velZ = 0; dispZ = 0; lastMotionT = null;

    startBarometer();
    startGeolocation();
    startAccelerometer();
    requestAnimationFrame(tick);
  }

  function stopAll(){
    running = false;
    startBtn.disabled = false; stopBtn.disabled = true;
    statusNote.textContent = '중지'; statusNote.classList.remove('ok');
    try{
      if (watchId != null) navigator.geolocation.clearWatch(watchId);
      watchId = null;
      if (baro && baro.stop) baro.stop();
      window.removeEventListener('devicemotion', ()=>{}, true); // generic remove
    }catch(e){}
  }

  startBtn.addEventListener('click', startAll);
  stopBtn.addEventListener('click', stopAll);
})();
</script>
</body>
</html>
